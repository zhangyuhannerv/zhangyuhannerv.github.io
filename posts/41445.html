<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>RabbitMq和SpringBoot的整合 | ZhangYuhanのblog</title><meta name="author" content="ZhangYuhan"><meta name="copyright" content="ZhangYuhan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="介绍该篇文章内容较多，包括有 rabbitMq 相关的一些简单理论介绍，provider 消息推送实例，consumer 消息消费实例，Direct、Topic、Fanout 的使用，消息回调、手动确认等。 （但是关于 rabbitMq 的安装，就不介绍了） 在安装完 rabbitMq 后，输入 http:&#x2F;&#x2F;ip:15672&#x2F; ，是可以看到一个简单后台管理界面的。  在这个界面里面我们可以做些什">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMq和SpringBoot的整合">
<meta property="og:url" content="https://zhangyuhan.netlify.app/posts/41445.html">
<meta property="og:site_name" content="ZhangYuhanのblog">
<meta property="og:description" content="介绍该篇文章内容较多，包括有 rabbitMq 相关的一些简单理论介绍，provider 消息推送实例，consumer 消息消费实例，Direct、Topic、Fanout 的使用，消息回调、手动确认等。 （但是关于 rabbitMq 的安装，就不介绍了） 在安装完 rabbitMq 后，输入 http:&#x2F;&#x2F;ip:15672&#x2F; ，是可以看到一个简单后台管理界面的。  在这个界面里面我们可以做些什">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.loliapi.com/acg/?uuid=41445">
<meta property="article:published_time" content="2023-03-16T09:36:44.000Z">
<meta property="article:modified_time" content="2024-11-06T03:52:15.559Z">
<meta property="article:author" content="ZhangYuhan">
<meta property="article:tag" content="Dev">
<meta property="article:tag" content="RabbitMq">
<meta property="article:tag" content="RabbitMq和SpringBoot的整合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.loliapi.com/acg/?uuid=41445"><link rel="shortcut icon" href="/img/theme/favicon.ico"><link rel="canonical" href="https://zhangyuhan.netlify.app/posts/41445.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RabbitMq和SpringBoot的整合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-06 11:52:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/card.css"><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZhangYuhanのblog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/theme/shenhe.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">207</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">269</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">66</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.loliapi.com/acg/?uuid=41445')"><nav id="nav"><span id="blog-info"><a href="/" title="ZhangYuhanのblog"><img class="site-icon" src="/img/theme/logo.png"/></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RabbitMq和SpringBoot的整合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-03-16T09:36:44.000Z" title="Created 2023-03-16 17:36:44">2023-03-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-06T03:52:15.559Z" title="Updated 2024-11-06 11:52:15">2024-11-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Dev/">Dev</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Dev/RabbitMq/">RabbitMq</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>32min</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/posts/41445.html" data-flag-title="RabbitMq和SpringBoot的整合"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/posts/41445.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/41445.html" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该篇文章内容较多，包括有 rabbitMq 相关的一些简单理论介绍，provider 消息推送实例，consumer 消息消费实例，Direct、Topic、Fanout 的使用，消息回调、手动确认等。 （但是关于 rabbitMq 的安装，就不介绍了）</p>
<p>在安装完 rabbitMq 后，输入 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://ip:15672/">http://ip:15672/</a> ，是可以看到一个简单后台管理界面的。</p>
<p><img src="https://s2.loli.net/2023/03/16/JpdQInSWVjZ8fOA.png" alt="image.png"></p>
<p>在这个界面里面我们可以做些什么？<br>可以手动创建虚拟 host，创建用户，分配权限，创建交换机，创建队列等等，还有查看队列消息，消费效率，推送效率等等。</p>
<p>以上这些管理界面的操作在这篇暂时不做扩展描述，我想着重介绍后面实例里会使用到的。</p>
<p>首先先介绍一个简单的一个消息推送到接收的流程，提供一个简单的图：</p>
<p><img src="https://s2.loli.net/2023/03/16/wlBdpUcToVziZMF.png" alt="image.png"></p>
<p>黄色的圈圈就是我们的消息推送服务，将消息推送到 中间方框里面也就是 rabbitMq 的服务器，然后经过服务器里面的交换机、队列等各种关系（后面会详细讲）将数据处理入列后，最终右边的蓝色圈圈消费者获取对应监听的消息。</p>
<p>常用的交换机有以下三种，因为消费者是从队列获取信息的，队列是绑定交换机的（一般），所以对应的消息推送/接收模式也会有以下几种：</p>
<ul>
<li><p>Direct Exchange</p>
<p>直连型交换机，根据消息携带的路由键将消息投递给对应队列。</p>
<p>大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key 。然后当一个消息携带着路由值为 X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值 X 去寻找绑定值也是 X 的队列。</p>
</li>
<li><p>Fanout Exchange</p>
<p>扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。</p>
</li>
<li><p>Topic Exchange</p>
<p>主题交换机，这个交换机其实跟直连交换机流程差不多，但是它的特点就是在它的路由键和绑定键之间是有规则的。<br>简单地介绍下规则：</p>
<p>* (星号) 用来表示一个单词 (必须出现的)<br># (井号) 用来表示任意数量（零个或多个）单词<br>通配的绑定键是跟队列进行绑定的，举个小例子</p>
<ul>
<li>队列 Q1 绑定键为 <em>.TT.</em> 队列 Q2 绑定键为 TT.#</li>
<li>如果一条消息携带的路由键为 A.TT.B，那么队列 Q1 将会收到；</li>
<li>如果一条消息携带的路由键为 TT.AA.BB，那么队列 Q2 将会收到；</li>
</ul>
<p>主题交换机是非常强大的，为啥这么膨胀？<br>当一个队列的绑定键为 “#”（井号） 的时候，这个队列将会无视消息的路由键，接收所有的消息。<br>当 * (星号) 和 # (井号) 这两个特殊字符都未在绑定键中出现的时候，此时主题交换机就拥有的直连交换机的行为。<br>所以主题交换机也就实现了扇形交换机的功能，和直连交换机的功能。</p>
</li>
</ul>
<p>另外还有 Header Exchange 头交换机 ，Default Exchange 默认交换机，Dead Letter Exchange 死信交换机，这几个该篇暂不做讲述</p>
<h2 id="Direct-Exchange-直连交换机"><a href="#Direct-Exchange-直连交换机" class="headerlink" title="Direct Exchange 直连交换机"></a>Direct Exchange 直连交换机</h2><p>本次实例教程需要创建 2 个 springboot 项目，一个 rabbitmq-provider （生产者），一个 rabbitmq-consumer（消费者）。</p>
<p>首先创建 rabbitmq-provider，</p>
<p>pom.xml 里用到的 jar 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--rabbitmq--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后 application.yml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8021</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#给项目来个名字</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq-provider</span></span><br><span class="line">  <span class="comment">#配置rabbitMq 服务器</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="comment">#虚拟host 可以不设置,使用server默认host</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">JCcccHost</span></span><br></pre></td></tr></table></figure>
<p>ps：里面的虚拟 host 配置项不是必须的，我自己在 rabbitmq 服务上创建了自己的虚拟 host，所以我配置了；你们不创建，就不用加这个配置项。</p>
<p>那么怎么建一个单独的 host 呢？ 假如我就是想给某个项目接入，使用一个单独 host，顺便使用一个单独的账号，就好像我文中配置的 root 这样。</p>
<p>其实也很简便：</p>
<p>virtual-host 的创建：</p>
<p><img src="https://s2.loli.net/2023/03/16/8vNYEIGelSKXoyp.png" alt="image.png"></p>
<p>账号 user 的创建：</p>
<p><img src="https://s2.loli.net/2023/03/16/LERehnC7F8kZlys.png" alt="image.png"></p>
<p>然后记得给账号分配权限，指定使用某个 virtual host：</p>
<p><img src="https://s2.loli.net/2023/03/16/d4On9jLlE1652Mv.png" alt="image.png"></p>
<p>其实还可以特定指定交换机使用权等等</p>
<p><img src="https://s2.loli.net/2023/03/16/QkFnxdBgAuUrej9.png" alt="image.png"></p>
<p>回归正题，继续继续。</p>
<p>接着我们先使用下 direct exchange(直连型交换机),创建 DirectRabbitConfig.java（对于队列和交换机持久化以及连接使用设置，在注释里有说明，后面的不同交换机的配置就不做同样说明了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列 起名：TestDirectQueue</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">TestDirectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue(&quot;TestDirectQueue&quot;,true,true,false);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;TestDirectQueue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Direct交换机 起名：TestDirectExchange</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DirectExchange <span class="title function_">TestDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//  return new DirectExchange(&quot;TestDirectExchange&quot;,true,true);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;TestDirectExchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定  将队列和交换机绑定, 并设置用于匹配键：TestDirectRouting</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingDirect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(TestDirectQueue()).to(TestDirectExchange()).with(<span class="string">&quot;TestDirectRouting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DirectExchange <span class="title function_">lonelyDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;lonelyDirectExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写个简单的接口进行消息推送（根据需求也可以改为定时任务等等，具体看需求），SendMessageController.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;  <span class="comment">//使用RabbitTemplate,这提供了接收/发送等等方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendDirectMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendDirectMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> String.valueOf(UUID.randomUUID());</span><br><span class="line">        <span class="type">String</span> <span class="variable">messageData</span> <span class="operator">=</span> <span class="string">&quot;test message, hello!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">createTime</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;messageId&quot;</span>,messageId);</span><br><span class="line">        map.put(<span class="string">&quot;messageData&quot;</span>,messageData);</span><br><span class="line">        map.put(<span class="string">&quot;createTime&quot;</span>,createTime);</span><br><span class="line">        <span class="comment">//将消息携带绑定键值：TestDirectRouting 发送到交换机TestDirectExchange</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;TestDirectExchange&quot;</span>, <span class="string">&quot;TestDirectRouting&quot;</span>, map);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 rabbitmq-provider 项目运行，调用下接口:</p>
<p><img src="https://s2.loli.net/2023/03/17/9ESvzKViFMQZRlt.png" alt="image.png"></p>
<p>因为我们目前还没弄消费者 rabbitmq-consumer，消息没有被消费的，我们去 rabbitMq 管理页面看看，是否推送成功：</p>
<p><img src="https://s2.loli.net/2023/03/17/OI5mi6aVKSzAwu1.png" alt="image.png"></p>
<p>再看看队列（界面上的各个英文项代表什么意思，可以自己查查哈，对理解还是有帮助的）：</p>
<p><img src="https://s2.loli.net/2023/03/17/rTAQuIyB3hiRbvU.png" alt="image.png"></p>
<p>很好，消息已经推送到 rabbitMq 服务器上面了。</p>
<p>接下来，创建 rabbitmq-consumer 项目：</p>
<p>pom.xml 里的 jar 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--rabbitmq--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后是 application.yml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8022</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#给项目来个名字</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq-consumer</span></span><br><span class="line">  <span class="comment">#配置rabbitMq 服务器</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="comment">#虚拟host 可以不设置,使用server默认host</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">JCcccHost</span></span><br></pre></td></tr></table></figure>
<p>然后一样，创建 DirectRabbitConfig.java（消费者单纯的使用，其实可以不用添加这个配置，直接建后面的监听就好，使用注解来让监听器监听对应的队列即可。配置上了的话，其实消费者也是生成者的身份，也能推送该消息。）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列 起名：TestDirectQueue</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">TestDirectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;TestDirectQueue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Direct交换机 起名：TestDirectExchange</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DirectExchange <span class="title function_">TestDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;TestDirectExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定  将队列和交换机绑定, 并设置用于匹配键：TestDirectRouting</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingDirect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(TestDirectQueue()).to(TestDirectExchange()).with(<span class="string">&quot;TestDirectRouting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是创建消息接收监听类，DirectReceiver.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;TestDirectQueue&quot;)</span><span class="comment">//监听的队列名称 TestDirectQueue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Map testMessage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DirectReceiver消费者收到消息  : &quot;</span> + testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将 rabbitmq-consumer 项目运行起来，可以看到把之前推送的那条消息消费下来了：</p>
<p><img src="https://s2.loli.net/2023/03/17/prwMKD46aBzWS5Q.png" alt="image.png"></p>
<p>然后可以再继续调用 rabbitmq-provider 项目的推送消息接口，可以看到消费者即时消费消息：</p>
<p><img src="https://s2.loli.net/2023/03/17/nsamSqi3R4cHUOZ.png" alt="image.png"></p>
<p>那么直连交换机既然是一对一，那如果咱们配置多台监听绑定到同一个直连交互的同一个队列，会怎么样？</p>
<p><img src="https://s2.loli.net/2023/03/17/8dx1Pi9YL5rkcZT.png" alt="image.png"></p>
<p>可以看到是实现了轮询的方式对消息进行消费，而且不存在重复消费。</p>
<h2 id="Topic-Exchange-主题交换机。"><a href="#Topic-Exchange-主题交换机。" class="headerlink" title="Topic Exchange 主题交换机。"></a>Topic Exchange 主题交换机。</h2><p>在 rabbitmq-provider 项目里面创建 TopicRabbitConfig.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicRabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">//绑定键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">man</span> <span class="operator">=</span> <span class="string">&quot;topic.man&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">woman</span> <span class="operator">=</span> <span class="string">&quot;topic.woman&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">firstQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(TopicRabbitConfig.man);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">secondQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(TopicRabbitConfig.woman);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    TopicExchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;topicExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将firstQueue和topicExchange绑定,而且绑定的键值为topic.man</span></span><br><span class="line">    <span class="comment">//这样只要是消息携带的路由键是topic.man,才会分发到该队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(firstQueue()).to(exchange()).with(man);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将secondQueue和topicExchange绑定,而且绑定的键值为用上通配路由键规则topic.#</span></span><br><span class="line">    <span class="comment">// 这样只要是消息携带的路由键是以topic.开头,都会分发到该队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeMessage2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(secondQueue()).to(exchange()).with(<span class="string">&quot;topic.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后添加多 2 个接口，用于推送消息到主题交换机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@GetMapping(&quot;/sendTopicMessage1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendTopicMessage1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> String.valueOf(UUID.randomUUID());</span><br><span class="line">        <span class="type">String</span> <span class="variable">messageData</span> <span class="operator">=</span> <span class="string">&quot;message: M A N &quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">createTime</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        Map&lt;String, Object&gt; manMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        manMap.put(<span class="string">&quot;messageId&quot;</span>, messageId);</span><br><span class="line">        manMap.put(<span class="string">&quot;messageData&quot;</span>, messageData);</span><br><span class="line">        manMap.put(<span class="string">&quot;createTime&quot;</span>, createTime);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;topicExchange&quot;</span>, <span class="string">&quot;topic.man&quot;</span>, manMap);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendTopicMessage2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendTopicMessage2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> String.valueOf(UUID.randomUUID());</span><br><span class="line">        <span class="type">String</span> <span class="variable">messageData</span> <span class="operator">=</span> <span class="string">&quot;message: woman is all &quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">createTime</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        Map&lt;String, Object&gt; womanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        womanMap.put(<span class="string">&quot;messageId&quot;</span>, messageId);</span><br><span class="line">        womanMap.put(<span class="string">&quot;messageData&quot;</span>, messageData);</span><br><span class="line">        womanMap.put(<span class="string">&quot;createTime&quot;</span>, createTime);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;topicExchange&quot;</span>, <span class="string">&quot;topic.woman&quot;</span>, womanMap);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者这边已经完事，先不急着运行，在 rabbitmq-consumer 项目上，创建 TopicManReceiver.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.man&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicManReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Map testMessage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TopicManReceiver消费者收到消息  : &quot;</span> + testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再创建一个 TopicTotalReceiver.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.elegant.rabbitmqconsumer.receiver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.woman&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicTotalReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Map testMessage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TopicTotalReceiver消费者收到消息  : &quot;</span> + testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，加主题交换机的相关配置，TopicRabbitConfig.java（消费者一定要加这个配置吗？ 不需要的其实，理由在前面已经说过了。）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicRabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">//绑定键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">man</span> <span class="operator">=</span> <span class="string">&quot;topic.man&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">woman</span> <span class="operator">=</span> <span class="string">&quot;topic.woman&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">firstQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(TopicRabbitConfig.man);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">secondQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(TopicRabbitConfig.woman);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    TopicExchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;topicExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将firstQueue和topicExchange绑定,而且绑定的键值为topic.man</span></span><br><span class="line">    <span class="comment">//这样只要是消息携带的路由键是topic.man,才会分发到该队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(firstQueue()).to(exchange()).with(man);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将secondQueue和topicExchange绑定,而且绑定的键值为用上通配路由键规则topic.#</span></span><br><span class="line">    <span class="comment">// 这样只要是消息携带的路由键是以topic.开头,都会分发到该队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeMessage2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(secondQueue()).to(exchange()).with(<span class="string">&quot;topic.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把 rabbitmq-provider，rabbitmq-consumer 两个项目都跑起来，先调用/sendTopicMessage1 接口：</p>
<p><img src="https://s2.loli.net/2023/03/17/u6wmGs3gBKUCfHc.png" alt="image.png"></p>
<p>然后看消费者 rabbitmq-consumer 的控制台输出情况：<br>TopicManReceiver 监听队列 1，绑定键为：topic.man<br>TopicTotalReceiver 监听队列 2，绑定键为：topic.#<br>而当前推送的消息，携带的路由键为：topic.man</p>
<p>所以可以看到两个监听消费者 receiver 都成功消费到了消息，因为这两个 recevier 监听的队列的绑定键都能与这条消息携带的路由键匹配上。</p>
<p><img src="https://s2.loli.net/2023/03/17/nKV4aigjfWErqGO.png" alt="image.png"></p>
<p>接下来调用接口/sendTopicMessage2:</p>
<p><img src="https://s2.loli.net/2023/03/17/8SOFgxX6teNHjoV.png" alt="image.png"></p>
<p>然后看消费者 rabbitmq-consumer 的控制台输出情况：<br>TopicManReceiver 监听队列 1，绑定键为：topic.man<br>TopicTotalReceiver 监听队列 2，绑定键为：topic.#<br>而当前推送的消息，携带的路由键为：topic.woman</p>
<p>所以可以看到两个监听消费者只有 TopicTotalReceiver 成功消费到了消息。</p>
<p><img src="https://s2.loli.net/2023/03/17/fGrFMjyROH3k6vK.png" alt="image.png"></p>
<h2 id="Fanout-Exchang-扇型交换机。"><a href="#Fanout-Exchang-扇型交换机。" class="headerlink" title="Fanout Exchang 扇型交换机。"></a>Fanout Exchang 扇型交换机。</h2><p>先在 rabbitmq-provider 项目上创建 FanoutRabbitConfig.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  创建三个队列 ：fanout.A   fanout.B  fanout.C</span></span><br><span class="line"><span class="comment">     *  将三个队列都绑定在交换机 fanoutExchange 上</span></span><br><span class="line"><span class="comment">     *  因为是扇型交换机, 路由键无需配置,配置也不起作用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanoutExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是写一个接口用于推送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sendFanoutMessage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sendFanoutMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> String.valueOf(UUID.randomUUID());</span><br><span class="line">    <span class="type">String</span> <span class="variable">messageData</span> <span class="operator">=</span> <span class="string">&quot;message: testFanoutMessage &quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">createTime</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;messageId&quot;</span>, messageId);</span><br><span class="line">    map.put(<span class="string">&quot;messageData&quot;</span>, messageData);</span><br><span class="line">    map.put(<span class="string">&quot;createTime&quot;</span>, createTime);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;fanoutExchange&quot;</span>, <span class="literal">null</span>, map);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在 rabbitmq-consumer 项目里加上消息消费类，</p>
<p>FanoutReceiverA.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.A&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutReceiverA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Map testMessage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FanoutReceiverA消费者收到消息  : &quot;</span> +testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FanoutReceiverB.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.B&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutReceiverB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Map testMessage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FanoutReceiverB消费者收到消息  : &quot;</span> +testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FanoutReceiverC.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.C&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutReceiverC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Map testMessage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FanoutReceiverC消费者收到消息  : &quot;</span> +testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后加上扇型交换机的配置类，FanoutRabbitConfig.java（消费者真的要加这个配置吗？ 不需要的其实，理由在前面已经说过了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  创建三个队列 ：fanout.A   fanout.B  fanout.C</span></span><br><span class="line"><span class="comment">     *  将三个队列都绑定在交换机 fanoutExchange 上</span></span><br><span class="line"><span class="comment">     *  因为是扇型交换机, 路由键无需配置,配置也不起作用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanoutExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将 rabbitmq-provider 和 rabbitmq-consumer 项目都跑起来，调用下接口/sendFanoutMessage ：</p>
<p><img src="https://s2.loli.net/2023/03/17/IfmFxgY6R2jnhsb.png" alt="image.png"></p>
<p>然后看看 rabbitmq-consumer 项目的控制台情况：</p>
<p><img src="https://s2.loli.net/2023/03/17/j6pT1PLaMAlFE8h.png" alt="image.png"></p>
<p>可以看到只要发送到 fanoutExchange 这个扇型交换机的消息， 三个队列都绑定这个交换机，所以三个消息接收类都监听到了这条消息。</p>
<p>到了这里其实三个常用的交换机的使用我们已经完毕，那么接下来我们继续讲讲消息的回调，其实就是消息确认（生产者推送消息成功，消费者接收消息成功）。</p>
<h2 id="生产者发布消息确认"><a href="#生产者发布消息确认" class="headerlink" title="生产者发布消息确认"></a>生产者发布消息确认</h2><p><strong>ps： 本篇文章使用 springboot 版本为 2.1.7.RELEASE ;<br>如果你们在配置确认回调，测试发现无法触发回调函数，那么存在原因也许是因为版本导致的配置项不起效，<br>可以把 publisher-confirms: true 替换为 publisher-confirm-type: correlated</strong></p>
<p>配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8021</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#给项目来个名字</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq-provider</span></span><br><span class="line">  <span class="comment">#配置rabbitMq 服务器</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="comment">#虚拟host 可以不设置,使用server默认host</span></span><br><span class="line">    <span class="attr">virtual-host:</span></span><br><span class="line">      <span class="string">JCcccHost</span></span><br><span class="line">      <span class="comment">#确认消息已发送到交换机(Exchange)</span></span><br><span class="line">    <span class="comment">#publisher-confirms: true</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span></span><br><span class="line">      <span class="string">correlated</span></span><br><span class="line">      <span class="comment">#确认消息已发送到队列(Queue)</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>然后是配置相关的消息确认回调函数，RabbitConfig.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RabbitTemplate <span class="title function_">createRabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>();</span><br><span class="line">        rabbitTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">//设置开启Mandatory,才能触发回调函数,无论消息推送结果怎么样都强制调用回调函数</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ConfirmCallback:     &quot;</span>+<span class="string">&quot;相关数据：&quot;</span>+correlationData);</span><br><span class="line">                System.out.println(<span class="string">&quot;ConfirmCallback:     &quot;</span>+<span class="string">&quot;确认情况：&quot;</span>+ack);</span><br><span class="line">                System.out.println(<span class="string">&quot;ConfirmCallback:     &quot;</span>+<span class="string">&quot;原因：&quot;</span>+cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;消息：&quot;</span>+message);</span><br><span class="line">                System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;回应码：&quot;</span>+replyCode);</span><br><span class="line">                System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;回应信息：&quot;</span>+replyText);</span><br><span class="line">                System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;交换机：&quot;</span>+exchange);</span><br><span class="line">                System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;路由键：&quot;</span>+routingKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，生产者推送消息的消息确认调用回调函数已经完毕。<br>可以看到上面写了两个回调函数，一个叫 ConfirmCallback ，一个叫 RetrunCallback；<br>那么以上这两种回调函数都是在什么情况会触发呢？</p>
<p>先从总体的情况分析，推送消息存在四种情况：</p>
<ul>
<li>消息推送到 server，但是在 server 里找不到交换机</li>
<li>消息推送到 server，找到交换机了，但是没找到队列</li>
<li>消息推送到 sever，交换机和队列啥都没找到</li>
<li>消息推送成功</li>
</ul>
<p>那么我先写几个接口来分别测试和认证下以上 4 种情况，消息确认触发回调函数的情况：</p>
<h3 id="消息推送到-server，但是在-server-里找不到交换机"><a href="#消息推送到-server，但是在-server-里找不到交换机" class="headerlink" title="消息推送到 server，但是在 server 里找不到交换机"></a>消息推送到 server，但是在 server 里找不到交换机</h3><p>写个测试接口，把消息推送到名为‘non-existent-exchange’的交换机上（这个交换机是没有创建没有配置的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/TestMessageAck&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">TestMessageAck</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> String.valueOf(UUID.randomUUID());</span><br><span class="line">    <span class="type">String</span> <span class="variable">messageData</span> <span class="operator">=</span> <span class="string">&quot;message: non-existent-exchange test message &quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">createTime</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;messageId&quot;</span>, messageId);</span><br><span class="line">    map.put(<span class="string">&quot;messageData&quot;</span>, messageData);</span><br><span class="line">    map.put(<span class="string">&quot;createTime&quot;</span>, createTime);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;non-existent-exchange&quot;</span>, <span class="string">&quot;TestDirectRouting&quot;</span>, map);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用接口，查看 rabbitmq-provuder 项目的控制台输出情况（原因里面有说，没有找到交换机’non-existent-exchange’）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-09-04 09:37:45.197 ERROR 8172 --- [ 127.0.0.1:5672] o.s.a.r.c.CachingConnectionFactory       : Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange &#x27;non-existent-exchange&#x27; in vhost &#x27;JCcccHost&#x27;, class-id=60, method-id=40)</span><br><span class="line">ConfirmCallback:     相关数据：null</span><br><span class="line">ConfirmCallback:     确认情况：false</span><br><span class="line">ConfirmCallback:     原因：channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange &#x27;non-existent-exchange&#x27; in vhost &#x27;JCcccHost&#x27;, class-id=60, method-id=40)</span><br></pre></td></tr></table></figure>
<p>结论： 这种情况触发的是 ConfirmCallback 回调函数。</p>
<h3 id="消息推送到-server，找到交换机了，但是没找到队列"><a href="#消息推送到-server，找到交换机了，但是没找到队列" class="headerlink" title="消息推送到 server，找到交换机了，但是没找到队列"></a>消息推送到 server，找到交换机了，但是没找到队列</h3><p>这种情况就是需要新增一个交换机，但是不给这个交换机绑定队列，我来简单地在 DirectRabitConfig 里面新增一个直连交换机，名叫‘lonelyDirectExchange’，但没给它做任何绑定配置操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">DirectExchange <span class="title function_">lonelyDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;lonelyDirectExchange&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写个测试接口，把消息推送到名为‘lonelyDirectExchange’的交换机上（这个交换机是没有任何队列配置的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/TestMessageAck2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">TestMessageAck2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> String.valueOf(UUID.randomUUID());</span><br><span class="line">    <span class="type">String</span> <span class="variable">messageData</span> <span class="operator">=</span> <span class="string">&quot;message: lonelyDirectExchange test message &quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">createTime</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;messageId&quot;</span>, messageId);</span><br><span class="line">    map.put(<span class="string">&quot;messageData&quot;</span>, messageData);</span><br><span class="line">    map.put(<span class="string">&quot;createTime&quot;</span>, createTime);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;lonelyDirectExchange&quot;</span>, <span class="string">&quot;TestDirectRouting&quot;</span>, map);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用接口，查看 rabbitmq-provuder 项目的控制台输出情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReturnCallback:     消息：(Body:&#x27;&#123;createTime=2019-09-04 09:48:01, messageId=563077d9-0a77-4c27-8794-ecfb183eac80, messageData=message: lonelyDirectExchange test message &#125;&#x27; MessageProperties [headers=&#123;&#125;, contentType=application/x-java-serialized-object, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0])</span><br><span class="line">ReturnCallback:     回应码：312</span><br><span class="line">ReturnCallback:     回应信息：NO_ROUTE</span><br><span class="line">ReturnCallback:     交换机：lonelyDirectExchange</span><br><span class="line">ReturnCallback:     路由键：TestDirectRouting</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConfirmCallback:     相关数据：null</span><br><span class="line">ConfirmCallback:     确认情况：true</span><br><span class="line">ConfirmCallback:     原因：null</span><br></pre></td></tr></table></figure>
<p>可以看到这种情况，两个函数都被调用了；</p>
<p>这种情况下，消息是推送成功到服务器了的，所以 ConfirmCallback 对消息确认情况是 true；<br>而在 RetrunCallback 回调函数的打印参数里面可以看到，消息是推送到了交换机成功了，但是在路由分发给队列的时候，找不到队列，所以报了错误 NO_ROUTE 。</p>
<p>结论： 这种情况触发的是 ConfirmCallback 和 RetrunCallback 两个回调函数。</p>
<h3 id="消息推送到-sever，交换机和队列啥都没找到"><a href="#消息推送到-sever，交换机和队列啥都没找到" class="headerlink" title="消息推送到 sever，交换机和队列啥都没找到"></a>消息推送到 sever，交换机和队列啥都没找到</h3><p>这种情况其实一看就觉得跟和没有找到交换机很像，所以情况和回调是一致的，所以不做结果说明了。</p>
<p>结论： 这种情况触发的是 ConfirmCallback 回调函数。</p>
<h3 id="消息推送成功"><a href="#消息推送成功" class="headerlink" title="消息推送成功"></a>消息推送成功</h3><p>那么测试下，按照正常调用之前消息推送的接口就行，就调用下 /sendFanoutMessage 接口，可以看到控制台输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfirmCallback:     相关数据：<span class="literal">null</span></span><br><span class="line">ConfirmCallback:     确认情况：<span class="literal">true</span></span><br><span class="line">ConfirmCallback:     原因：<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>结论：这种情况触发的是 ConfirmCallback 回调函数。</p>
<p>以上是生产者推送消息的消息确认 回调函数的使用介绍（可以在回调函数根据需求做对应的扩展或者业务数据处理）。</p>
<h2 id="消费者消费消息确认"><a href="#消费者消费消息确认" class="headerlink" title="消费者消费消息确认"></a>消费者消费消息确认</h2><h3 id="消费者消费确认介绍"><a href="#消费者消费确认介绍" class="headerlink" title="消费者消费确认介绍"></a>消费者消费确认介绍</h3><p>和生产者的消息确认机制不同，因为消息接收本来就是在监听消息，符合条件的消息就会消费下来。<br>所以，消息接收的确认机制主要存在三种模式：</p>
<ul>
<li><p>自动确认， 这也是默认的消息确认情况。 AcknowledgeMode.NONE<br>RabbitMQ 成功将消息发出（即将消息成功写入 TCP Socket）中立即认为本次投递已经被正确处理，不管消费者端是否成功处理本次投递。<br>所以这种情况如果消费端消费逻辑抛出异常，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息。<br>一般这种情况我们都是使用 try catch 捕捉异常后，打印日志用于追踪数据，这样找出对应数据再做后续处理。</p>
</li>
<li><p>根据情况确认， 这个不做介绍</p>
</li>
<li><p>手动确认 ， 这个比较关键，也是我们配置接收消息确认机制时，多数选择的模式。消费者收到消息后，手动调用 basic.ack/basic.nack/basic.reject 后，RabbitMQ 收到这些消息后，才认为本次投递成功。</p>
<ul>
<li>basic.ack 用于肯定确认</li>
<li>basic.nack 用于否定确认（注意：这是 AMQP 0-9-1 的 RabbitMQ 扩展）</li>
<li>basic.reject 用于否定确认，但与 basic.nack 相比有一个限制:一次只能拒绝单条消息</li>
</ul>
</li>
</ul>
<p>消费者端以上的 3 个方法都表示消息已经被正确投递，但是 basic.ack 表示消息已经被正确处理。</p>
<p>而 basic.nack,basic.reject 表示没有被正确处理。</p>
<p>着重讲下 reject，因为有时候一些场景是需要重新入列的。</p>
<p>channel.basicReject(deliveryTag, true); 拒绝消费当前消息，如果第二参数传入 true，就是将数据重新丢回队列里，那么下次还会消费这消息。设置 false，就是告诉服务器，我已经知道这条消息数据了，因为一些原因拒绝它，而且服务器也把这个消息丢掉就行。 下次不想再消费这条消息了。</p>
<p>使用拒绝后重新入列这个确认模式要谨慎，因为一般都是出现异常的时候，catch 异常再拒绝入列，选择是否重入列。</p>
<p>但是如果使用不当会导致一些每次都被你重入列的消息一直消费-入列-消费-入列这样循环，会导致消息积压。</p>
<p>顺便也简单讲讲 nack，这个也是相当于设置不消费某条消息。</p>
<p>channel.basicNack(deliveryTag, false, true);<br>第一个参数依然是当前消息到的数据的唯一 id;<br>第二个参数是指是否针对多条消息；如果是 true，也就是说一次性针对当前通道的消息的 tagID 小于当前这条消息的，都拒绝确认。<br>第三个参数是指是否重新入列，也就是指不确认的消息是否重新丢回到队列里面去。</p>
<p>同样使用不确认后重新入列这个确认模式要谨慎，因为这里也可能因为考虑不周出现消息一直被重新丢回去的情况，导致积压。</p>
<h3 id="消费者消费确认代码"><a href="#消费者消费确认代码" class="headerlink" title="消费者消费确认代码"></a>消费者消费确认代码</h3><p>在消费者项目里，<br>新建 MessageListenerConfig.java 上添加代码相关的配置代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.elegant.rabbitmqconsumer.receiver.MyAckReceiver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AcknowledgeMode;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CachingConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : JCccc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> : 2019/9/4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListenerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CachingConnectionFactory connectionFactory;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAckReceiver myAckReceiver;<span class="comment">//消息接收处理类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleMessageListenerContainer <span class="title function_">simpleMessageListenerContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleMessageListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMessageListenerContainer</span>(connectionFactory);</span><br><span class="line">        container.setConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">        container.setMaxConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">        container.setAcknowledgeMode(AcknowledgeMode.MANUAL); <span class="comment">// RabbitMQ默认是自动确认，这里改为手动确认消息</span></span><br><span class="line">        <span class="comment">//设置一个队列</span></span><br><span class="line">        container.setQueueNames(<span class="string">&quot;TestDirectQueue&quot;</span>);</span><br><span class="line">        <span class="comment">//如果同时设置多个如下： 前提是队列都是必须已经创建存在的</span></span><br><span class="line">        <span class="comment">//  container.setQueueNames(&quot;TestDirectQueue&quot;,&quot;TestDirectQueue2&quot;,&quot;TestDirectQueue3&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//另一种设置队列的方法,如果使用这种情况,那么要设置多个,就使用addQueues</span></span><br><span class="line">        <span class="comment">//container.setQueues(new Queue(&quot;TestDirectQueue&quot;,true));</span></span><br><span class="line">        <span class="comment">//container.addQueues(new Queue(&quot;TestDirectQueue2&quot;,true));</span></span><br><span class="line">        <span class="comment">//container.addQueues(new Queue(&quot;TestDirectQueue3&quot;,true));</span></span><br><span class="line">        container.setMessageListener(myAckReceiver);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的手动确认消息监听类，MyAckReceiver.java（手动确认模式需要实现 ChannelAwareMessageListener）：<br>之前的相关监听器可以先注释掉，以免造成多个同类型监听器都监听同一个队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAckReceiver</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(body));</span><br><span class="line">            Map&lt;String,String&gt; msgMap = (Map&lt;String,String&gt;) ois.readObject();</span><br><span class="line">            <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> msgMap.get(<span class="string">&quot;messageId&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">messageData</span> <span class="operator">=</span> msgMap.get(<span class="string">&quot;messageData&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">createTime</span> <span class="operator">=</span> msgMap.get(<span class="string">&quot;createTime&quot;</span>);</span><br><span class="line">            ois.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;  MyAckReceiver  messageId:&quot;</span>+messageId+<span class="string">&quot;  messageData:&quot;</span>+messageData+<span class="string">&quot;  createTime:&quot;</span>+createTime);</span><br><span class="line">            System.out.println(<span class="string">&quot;消费的主题消息来自：&quot;</span>+message.getMessageProperties().getConsumerQueue());</span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>); <span class="comment">//第二个参数，手动确认可以被批处理，当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的所有消息</span></span><br><span class="line"><span class="comment">//			channel.basicReject(deliveryTag, true);//第二个参数，true会重新放回队列，所以需要自己根据业务逻辑判断什么时候使用拒绝</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            channel.basicReject(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时，先调用接口/sendDirectMessage， 给直连交换机 TestDirectExchange 的队列 TestDirectQueue 推送一条消息，可以看到监听器正常消费了下来：</p>
<p><img src="https://s2.loli.net/2023/03/17/fw2PEWtqO4RzBon.png" alt="image.png"></p>
<p>到这里，其实已经掌握了怎么去使用消息消费的手动确认了。</p>
<p>但是这个场景往往不够！ 某些消费者项目里面，监听的好几个队列都想变成手动确认模式，而且处理的消息业务逻辑不一样。</p>
<p>没有问题，接下来看代码</p>
<p>场景： 除了直连交换机的队列 TestDirectQueue 需要变成手动确认以外，我们还需要将一个其他的队列</p>
<p>或者多个队列也变成手动确认，而且不同队列实现不同的业务处理。</p>
<p>那么我们需要做的第一步，往 SimpleMessageListenerContainer 里添加多个队列：</p>
<p><img src="https://s2.loli.net/2023/03/17/MSyoXBK59xZIWup.png" alt="20200426111011644.png"></p>
<p>然后我们的手动确认消息监听类，MyAckReceiver.java 就可以同时将上面设置到的队列的消息都消费下来。</p>
<p>但是我们需要做不用的业务逻辑处理，那么只需要 根据消息来自的队列名进行区分处理即可，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAckReceiver</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(body));</span><br><span class="line">            Map&lt;String,String&gt; msgMap = (Map&lt;String,String&gt;) ois.readObject();</span><br><span class="line">            <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> msgMap.get(<span class="string">&quot;messageId&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">messageData</span> <span class="operator">=</span> msgMap.get(<span class="string">&quot;messageData&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">createTime</span> <span class="operator">=</span> msgMap.get(<span class="string">&quot;createTime&quot;</span>);</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;TestDirectQueue&quot;</span>.equals(message.getMessageProperties().getConsumerQueue()))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费的消息来自的队列名为：&quot;</span>+message.getMessageProperties().getConsumerQueue());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息成功消费到  messageId:&quot;</span>+messageId+<span class="string">&quot;  messageData:&quot;</span>+messageData+<span class="string">&quot;  createTime:&quot;</span>+createTime);</span><br><span class="line">                System.out.println(<span class="string">&quot;执行TestDirectQueue中的消息的业务处理流程......&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;fanout.A&quot;</span>.equals(message.getMessageProperties().getConsumerQueue()))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费的消息来自的队列名为：&quot;</span>+message.getMessageProperties().getConsumerQueue());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息成功消费到  messageId:&quot;</span>+messageId+<span class="string">&quot;  messageData:&quot;</span>+messageData+<span class="string">&quot;  createTime:&quot;</span>+createTime);</span><br><span class="line">                System.out.println(<span class="string">&quot;执行fanout.A中的消息的业务处理流程......&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//			channel.basicReject(deliveryTag, true);//为true会重新放回队列</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            channel.basicReject(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，这时候我们来分别往不同队列推送消息，看看效果：</p>
<p>调用接口/sendDirectMessage 和 /sendFanoutMessage ，</p>
<p><img src="https://s2.loli.net/2023/03/17/CU8JhGwg6mVOcQ5.png" alt="image.png"></p>
<p>如果你还想新增其他的监听队列，也就是按照这种方式新增配置即可（或者完全可以分开多个消费者项目去监听处理）。</p>
<p>好，这篇 Springboot 整合 rabbitMq 教程就暂且到此。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://zhangyuhan.netlify.app/">ZhangYuhan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://zhangyuhan.netlify.app/posts/41445.html">https://zhangyuhan.netlify.app/posts/41445.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Dev/">Dev</a><a class="post-meta__tags" href="/tags/RabbitMq/">RabbitMq</a><a class="post-meta__tags" href="/tags/RabbitMq%E5%92%8CSpringBoot%E7%9A%84%E6%95%B4%E5%90%88/">RabbitMq和SpringBoot的整合</a></div><div class="post_share"><div class="social-share" data-image="https://www.loliapi.com/acg/?uuid=41445" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/theme/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/theme/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/theme/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/theme/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/8942.html" title="RabbitMq博客整理"><img class="cover" src="https://www.loliapi.com/acg/?uuid=8942" onerror="onerror=null;src='/img/theme/pictureLost.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">RabbitMq博客整理</div></div></a></div><div class="next-post pull-right"><a href="/posts/33806.html" title="利用jar命令修改jar包中文件的内容"><img class="cover" src="https://www.loliapi.com/acg/?uuid=33806" onerror="onerror=null;src='/img/theme/pictureLost.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">利用jar命令修改jar包中文件的内容</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/8942.html" title="RabbitMq博客整理"><img class="cover" src="https://www.loliapi.com/acg/?uuid=8942" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-21</div><div class="title">RabbitMq博客整理</div></div></a></div><div><a href="/posts/56360.html" title="m1,docker安装rabbitmq"><img class="cover" src="https://www.loliapi.com/acg/?uuid=56360" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="title">m1,docker安装rabbitmq</div></div></a></div><div><a href="/posts/4225.html" title="学习路线"><img class="cover" src="https://www.loliapi.com/acg/?uuid=747d53cdd9ed4fb1bf889f5bdc06d9dd" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="title">学习路线</div></div></a></div><div><a href="/posts/7682.html" title="待学习"><img class="cover" src="https://www.loliapi.com/acg/?uuid=abd1bbcd6dfd4839a75ceda557bcd850" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="title">待学习</div></div></a></div><div><a href="/posts/281.html" title="判断字符串相等时的注意事项"><img class="cover" src="https://www.loliapi.com/acg/?uuid=281" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="title">判断字符串相等时的注意事项</div></div></a></div><div><a href="/posts/27592.html" title="mybatis中$和#的使用场景"><img class="cover" src="https://www.loliapi.com/acg/?uuid=337ca8f79fe6492b8340c3d7936e4a99" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="title">mybatis中$和#的使用场景</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/theme/shenhe.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZhangYuhan</div><div class="author-info__description">(o゜▽゜)o☆[BINGO!]</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">207</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">269</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">66</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/ayanamiichi"><i class="fa-brands fa-twitter"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangyuhannerv" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zhangyuhannerv@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Welcome to my blog, here is a summary of my daily study and life collected and organized, I hope it can be helpful to you ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Direct-Exchange-%E7%9B%B4%E8%BF%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">2.</span> <span class="toc-text">Direct Exchange 直连交换机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Topic-Exchange-%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%82"><span class="toc-number">3.</span> <span class="toc-text">Topic Exchange 主题交换机。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fanout-Exchang-%E6%89%87%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%82"><span class="toc-number">4.</span> <span class="toc-text">Fanout Exchang 扇型交换机。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="toc-number">5.</span> <span class="toc-text">生产者发布消息确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%88%B0-server%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8-server-%E9%87%8C%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">5.1.</span> <span class="toc-text">消息推送到 server，但是在 server 里找不到交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%88%B0-server%EF%BC%8C%E6%89%BE%E5%88%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%BA%86%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B2%A1%E6%89%BE%E5%88%B0%E9%98%9F%E5%88%97"><span class="toc-number">5.2.</span> <span class="toc-text">消息推送到 server，找到交换机了，但是没找到队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%88%B0-sever%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E9%98%9F%E5%88%97%E5%95%A5%E9%83%BD%E6%B2%A1%E6%89%BE%E5%88%B0"><span class="toc-number">5.3.</span> <span class="toc-text">消息推送到 sever，交换机和队列啥都没找到</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%88%90%E5%8A%9F"><span class="toc-number">5.4.</span> <span class="toc-text">消息推送成功</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="toc-number">6.</span> <span class="toc-text">消费者消费消息确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E7%A1%AE%E8%AE%A4%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.1.</span> <span class="toc-text">消费者消费确认介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E7%A1%AE%E8%AE%A4%E4%BB%A3%E7%A0%81"><span class="toc-number">6.2.</span> <span class="toc-text">消费者消费确认代码</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ZhangYuhan</div><div class="footer_custom_text">Hi, welcome to my blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'JkudL31UMA3LTrugX1MyaDSI-MdYXbMMI',
      appKey: 'G7H3CF0evPfzlwg7MCAK3ZJY',
      avatar: 'monsterid',
      serverURLs: 'https://jkudl31u.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, {"placeholder":"leave your comment (*￣▽￣*)ブ\nPs: Users in mainland China may need to surf the Internet scientifically to successfully load and submit comments\n","pageSize":15,"lang":"en"}))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script><script type="text/javascript" src="/js/dynamicBg.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>